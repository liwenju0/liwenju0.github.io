---
layout: post
title:  "ROPE位置编码"
date:   2025-06-24 09:20:08 +0800
category: "AI"
published: true
---

ROPE位置编码的文章很多，苏神的博客也讲得很清楚，为什么我还要写一篇？因为我想按照自己的思路捋一下，就酱紫。

<!--more-->

## 1、为什么需要位置编码-Transformer的对称性缺陷
<div id="function-demo" style="width: 100%; height: 300px; border: 1px solid #ccc; margin: 20px 0; position: relative; background: #f9f9f9;">
  <canvas id="functionCanvas" width="800" height="300" style="width: 100%; height: 100%;"></canvas>
</div>

<button onclick="drawSineWave()" style="margin: 10px 5px; padding: 8px 16px; background: #4CAF50; color: white; border: none; border-radius: 4px; cursor: pointer;">正弦函数</button>
<button onclick="drawCosineWave()" style="margin: 10px 5px; padding: 8px 16px; background: #2196F3; color: white; border: none; border-radius: 4px; cursor: pointer;">余弦函数</button>
<button onclick="drawBothWaves()" style="margin: 10px 5px; padding: 8px 16px; background: #FF9800; color: white; border: none; border-radius: 4px; cursor: pointer;">两个函数</button>
<button onclick="clearCanvas()" style="margin: 10px 5px; padding: 8px 16px; background: #666; color: white; border: none; border-radius: 4px; cursor: pointer;">清空画布</button>

<script>
let canvas, ctx;
let animationId;

function initCanvas() {
  canvas = document.getElementById('functionCanvas');
  if (!canvas) return;
  
  ctx = canvas.getContext('2d');
  canvas.width = 800;
  canvas.height = 300;
  
  // 绘制坐标轴
  drawAxes();
}

function drawAxes() {
  ctx.clearRect(0, 0, canvas.width, canvas.height);
  ctx.strokeStyle = '#ddd';
  ctx.lineWidth = 1;
  
  // X轴
  ctx.beginPath();
  ctx.moveTo(0, canvas.height / 2);
  ctx.lineTo(canvas.width, canvas.height / 2);
  ctx.stroke();
  
  // Y轴
  ctx.beginPath();
  ctx.moveTo(50, 0);
  ctx.lineTo(50, canvas.height);
  ctx.stroke();
  
  // 添加标签
  ctx.fillStyle = '#666';
  ctx.font = '12px Arial';
  ctx.fillText('位置', canvas.width - 30, canvas.height / 2 + 15);
  ctx.fillText('编码值', 55, 15);
}

function drawSineWave() {
  if (animationId) cancelAnimationFrame(animationId);
  drawAxes();
  
  let x = 0;
  function animate() {
    if (x > canvas.width - 50) {
      x = 0;
      drawAxes();
    }
    
    ctx.strokeStyle = '#4CAF50';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    for (let i = 0; i <= x; i++) {
      const y = canvas.height / 2 + 80 * Math.sin((i - 50) * 0.02);
      if (i === 0) {
        ctx.moveTo(i + 50, y);
      } else {
        ctx.lineTo(i + 50, y);
      }
    }
    ctx.stroke();
    
    x += 2;
    animationId = requestAnimationFrame(animate);
  }
  animate();
}

function drawCosineWave() {
  if (animationId) cancelAnimationFrame(animationId);
  drawAxes();
  
  let x = 0;
  function animate() {
    if (x > canvas.width - 50) {
      x = 0;
      drawAxes();
    }
    
    ctx.strokeStyle = '#2196F3';
    ctx.lineWidth = 2;
    ctx.beginPath();
    
    for (let i = 0; i <= x; i++) {
      const y = canvas.height / 2 + 80 * Math.cos((i - 50) * 0.02);
      if (i === 0) {
        ctx.moveTo(i + 50, y);
      } else {
        ctx.lineTo(i + 50, y);
      }
    }
    ctx.stroke();
    
    x += 2;
    animationId = requestAnimationFrame(animate);
  }
  animate();
}

function drawBothWaves() {
  if (animationId) cancelAnimationFrame(animationId);
  drawAxes();
  
  let x = 0;
  function animate() {
    if (x > canvas.width - 50) {
      x = 0;
      drawAxes();
    }
    
    // 绘制正弦波
    ctx.strokeStyle = '#4CAF50';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i <= x; i++) {
      const y = canvas.height / 2 + 60 * Math.sin((i - 50) * 0.02);
      if (i === 0) {
        ctx.moveTo(i + 50, y);
      } else {
        ctx.lineTo(i + 50, y);
      }
    }
    ctx.stroke();
    
    // 绘制余弦波
    ctx.strokeStyle = '#2196F3';
    ctx.lineWidth = 2;
    ctx.beginPath();
    for (let i = 0; i <= x; i++) {
      const y = canvas.height / 2 + 60 * Math.cos((i - 50) * 0.02);
      if (i === 0) {
        ctx.moveTo(i + 50, y);
      } else {
        ctx.lineTo(i + 50, y);
      }
    }
    ctx.stroke();
    
    x += 2;
    animationId = requestAnimationFrame(animate);
  }
  animate();
}

function clearCanvas() {
  if (animationId) cancelAnimationFrame(animationId);
  drawAxes();
}

// 页面加载时初始化
document.addEventListener('DOMContentLoaded', function() {
  setTimeout(initCanvas, 100);
});
</script>

<p style="color: #666; font-size: 14px; margin-top: 10px;">
💡 这些三角函数曲线展示了ROPE位置编码的基本思想：通过不同频率的正弦和余弦函数来为每个位置生成唯一的编码，使得模型能够理解token之间的相对位置关系。
</p>
